[o] heap
[x]   step 1. a vector of [*ptr,size] elements pointing to freed memory
[ ]   step 2. hash table on size with vectors [*ptr,size]
[ ]   step 3. libge heap optimized for Object
[ ]     O(1) delete and nearly O(1) alloc
[ ]       HeapElem{*prv,*nxt,ushort size,ubyte sizeh,ubyte bits} 12 B
[o] input text
[x]   step 1. one keyboard buffer for the system
[ ]   step 2. "osca_keyb_task" pointer to function that should read keyboard
[ ]   step 3. a way to switch keyboard focus to other tasks
[ ] investigate why any -O other than -O0,-O1,-Og breaks osca_keyb.next_scan_code(). see comment in function.
[ ] review const correctness regarding const bmp.data.begin.address then write to pointer
[ ]   const Bitmap&dbmp=dsp.bmp(); then mutate data in const dbmp
[ ] lib: PrinterToBitmap pos in pixels
[ ] lib: PrinterToConsole pos in characters
[ ] osca: time_ms
[x] extract boot.cc to boot.S
[ ] use link.ld to build binary?
[x] inline assembler for pz_memcpy
[ ]   clobbers memory?
[ ]   movsl,movsw,movsb optimization?
[x] test writing to second meg to confirm enabling of a20 line
[x]   is enabled by default in qemu and on asus zenbook
[x] bitmap
[ ]   optimized for 32b memcpy?
[o] sprite with transparency
[ ]   collision detection
[ ]     with background
[ ]     with other sprites
[o] 5x6 font (30 bits/character)
[x]   c code generated from font file -> done manually
[x] inline assembler character renderer -> written in C++
[x] print hex numbers
[x] scan code to ascii
[o] bmp printer
[x]   hex
[x]   characters
[x]   strings
[ ]   integers
[ ]   floats
[ ] pointing device
[ ]   events
[ ]     {byte event=move,byte pad,short x,short y} 6B
[ ]     {byte event=click,byte btn} 2B
[ ] kernel events to task
[ ]   pointer to task record of focused task
[ ]   in task record - pointer to ring buffer of events
[ ]   keyboard event
[ ]     {byte event=key,byte scan_code} 2B
[ ] task event loop
[ ]   task.next_event()->byte* // pointer to next event or 0 if done
