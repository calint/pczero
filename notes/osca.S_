# tested on:
# * dell inspiron 1545
# * asus-eeepc-4g
# * hp-compaq-mini-110
# * sony-vaio-vgnfw11m
# * qemu 0.11.0 on linux 2.6
# * qemu 7.0.0 on linux 5.19
# * asus zenbook
#
# 00000-003FF  IVT (Interrupt Vector Table)
# 00400-005FF  BDA (BIOS Data Area)
# 00600-9FFFF  Ordinary application RAM
# A0000-BFFFF  Video memory
# C0000-EFFFF  Optional ROMs (The VGA ROM is usually located at C0000)
# F0000-FFFFF  BIOS ROM
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - intro
.set IDT,0x600 # interrupt descriptor table address
.global osca_key # last pressed key
.global osca_tmr_lo # 1024 Hz timer low bits
.global osca_tmr_hi # 1024 Hz timer high bits
.global _start # export entry point

# used for task switching and accessed from osca_yield()
.global osca_yield
.global isr_tmr_yield
.global isr_tmr_switch_task
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - bpb
.code16 # boot in 16 bit mode
_start:
# jump over BIOS Parameter Block (BPB) because
# that memory may be written to by BIOS when booting from USB
jmp _main
.space 3-(.-_start),0x90 # support 2 or 3 bytes encoded jmp
.space 59,0x90 # BPB area that may be written to by BIOS
_main:
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - setup
cli # disable interrupts
# disable NMI? outb(0x70,inb(0x70)|0x80);inb(0x71);
xor %bx,%bx # clear bx
mov %bx,%ds # data segment
mov %dl,osca_drv_b # save boot drive
mov %bx,%ss # setup stack
mov $_start,%sp # at 0x7c00
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - load
cld # clear direction (forward)
# command 2 (%ah), sectors to read (%al) 0x3f (31½K)
#mov $0x023f,%ax
# read 128 sectors * 512B = 65536 bytes. maximum without DMA interrupt
mov $0x0280,%ax
# from cylinder 0 (%ch), sector 2 (%cl) (sector starts from 1, not 0)
mov $0x0002,%cx
xor %dh,%dh # head 0
# %dl, drive number, is unchanged
mov $0x07e0,%bx # to es:bx=7e00:0000
mov %bx,%es
xor %bx,%bx
int $0x13 # read disk
#jnc lbl1 # if no error
#  # error
#  mov $0xb800,%ax # console segment
#  mov %ax,%es
#  movw $0x4045,%es:0 # E 'E1' to top left corner
#  movw $0x4031,%es:2 # 1
#  hlt
#lbl1:
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - mode 13h
mov $0x13,%ax # vga mode 320x200x8 bmp @ 0xa0000
int $0x10
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - display
#movw $0x0404,%es:0x100
#mov $0xa000,%ax
#mov %ax,%es
#mov $0x0,%di
#mov $0x07c0,%si
#mov %si,%ds
#xor %si,%si
#mov $0xffff,%cx
#rep movsb
#xor %si,%si
#mov %si,%ds
#hlt
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - a20
# enable access to odd megs
# https://wiki.osdev.org/A20_Line
# enabled by default on non ancient pc?
#movw $0x0404,%es:0x104
in $0x92,%al
or $2,%al
out %al,$0x92
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 32b
#movw $0x0404,%es:0x108
lgdt gdtr # load global descriptor tables
mov %cr0,%eax # enter 32b protected mode
or $0x1,%al
mov %eax,%cr0
jmp $8,$protected_mode # jmp and flush
.align 16,0x90
gdt:.quad 0x0000000000000000 #0x00:
    .quad 0x00cf9a000000ffff #0x08: 32b code 4g pl0 rx
    .quad 0x00cf92000000ffff #0x10: 32b data 4g pl0 rw
    .quad 0x009f9a000000ffff #0x18: 16b code 1m rx
    .quad 0x009f92000000ffff #0x20: 16b data 1m rw
gdtr:.word gdtr-gdt-1,gdt,0,0
ivtr:.word 0x03ff
     .long 0x00000000
.align 8,0
idtr:.word 0x03ff
     .long IDT # idt address
.align 8,0x90
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - protected mode
protected_mode:
.code32
mov $0x10,%ax
mov %ax,%ss
mov %ax,%ds
mov %ax,%es
mov %ax,%fs
mov %ax,%gs
xor %eax,%eax
xor %ebx,%ebx
xor %ecx,%ecx
xor %edx,%edx
xor %edi,%edi
xor %esi,%esi
xor %ebp,%ebp
#movw $0x0404,0xa0110
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - isr
#movw $0x0404,0xa0114
mov $IDT,%ebx # idt address
mov $0x40,%ecx # interrupt count
lbl2:
    movw $isr_err,(%ebx) # offset 0..15
    movw $0x0008,2(%ebx) # selector in gdt
    movb $0x00,  4(%ebx) # unused
    movb $0x8e,  5(%ebx) # type_attrs p,pv0,!s,i32b
    movw $0x0000,6(%ebx) # offfset 16..31
    add $8,%bx
loop lbl2
#movl $0x0e0e0f0f,0xa0118 # on screen
# setup IRQ 0,1,8. keyboard, system timer and RTC timer
#  only the lower offset set, handlers within 64K
#  PIC reprogrammed in "map irqs" to map IRQ to IDT mapping 32-47
movw $isr_tck,IDT+(32+0)*8 # IRQ 0: keyboard
movw $isr_kbd,IDT+(32+1)*8 # IRQ 1: timer 18.2 Hz
movw $isr_tmr,IDT+(32+8)*8 # IRQ 8: timer 1024 Hz
lidt idtr
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - map irqs
# reprogram the PIC (8259's) to map IRQ 0-15 to IDT mapping 32 to 47
# https://en.wikibooks.org/wiki/X86_Assembly/Programmable_Interrupt_Controller
mov $0x11,%al
out %al,$0x20 # restart PIC1
out %al,$0xa0 # restart PIC2

mov $0x20,%al
out %al,$0x21 # PIC1 now starts at 32
mov $0x28,%al
out %al,$0xa1 # PIC2 now starts at 40

mov $0x04,%al
out %al,$0x21
mov $0x02,%al # setup cascading
out %al,$0xa1

mov $0x01,%al
out %al,$0x21
out %al,$0xa1 # done
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - irq 8 timer
# disable the Non-Maskable Interrupt (NMI) before programming RTC
# this interrupt happens when there is a critical hardware failure
# https://wiki.osdev.org/Non_Maskable_Interrupt
in $0x70,%al
or $0x80,%al
out %al,$0x70
in $0x71,%al
# enable RTC 1024 Hz timer on IRQ 8
# https://wiki.osdev.org/RTC
mov $0x8b,%al
out %al,$0x70
in $0x71,%al
mov %al,%dl
mov $0x8b,%al
out %al,$0x70
mov %dl,%al
or $0x40,%al
out %al,$0x71
# ? enable NMI
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - start
#movw $0x0404,0xa4000
call osca_init
mov osca_tsk_a,%ebx # ebx points to active task record
# potential bug? because eflags not restored and registers in unknown state?)
mov 4(%ebx),%esp # restore stack pointer
sti # enable interrupts (racing?)
jmp *(%ebx) # jmp to first task
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - vars
.align 16,0x90
osca_drv_b:.byte 0x00 # boot drive
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - partition
.space _start+436-.,0X90 # reserved
.space 10,0 # partition table
.space 16,0 # #1
.space 16,0 # #2
.space 16,0 # #3
.space 16,0 # #4
.word 0xaa55 # pc boot sector signature
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - interrupts
sector2: # 0x7e00
osca_tmr_lo:.long 0x00000000 # 1024 Hz tick lower
osca_tmr_hi:.long 0x00000000 # 1024 Hz tick higher
osca_tsk_a:.long tsk # pointer to first task record (tsk0)
isr_tmr_eax:.long 0x00000000 # used in isr_tmr
isr_tmr_ebx:.long 0x00000000 # ...
isr_tmr_esp:.long 0x00000000 # ...
isr_tmr_eip:.long 0x00000000 # ...
isr_tmr_eflags:.long 0x00000000 #...
isr_tmr_yield:.byte 0x00 # set to 1 if the task switch request is from osca_yield()
osca_key:.byte 0x00 # last key event
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - yield
.align 16,0x90
osca_yield:
  pushf #  push flags including interrupt flag. stack is now: IP, FLAGS
  cli # disable interrupts after pushing the flags
  movb $1,isr_tmr_yield # set mode for task_switch
  jmp isr_tmr_switch_task # do the rest of task switch
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - interrupts
# "*NOTE* Because IA-32 tasks are not re-entrant, an interrupt-handler
# task must disable interrupts between the time it completes handling
# the interrupt and the time it executes the IRET instruction. This
# action prevents another interrupt from occurring while the interrupt
# task's TSS is still marked busy, which would cause a general-protection
# (#GP) exception."
#
#—Intel Software Developer Manual
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- irq 8 timer
.align 16,0x90
isr_tmr:
  cli # disable interrupts
  incl 0xa0000+320-12
  incl osca_tmr_lo     # increase lower 32 bits ticker
  adcl $0,osca_tmr_hi  # add carry to upper 32 bits
  push %eax            # don't switch task at every tick
  mov osca_tmr_lo,%eax #
  and $0x1,%eax        # 1024/2 Hz (running at 1024 Hz hangs Asus Zenbook)
  pop %eax             #
  jz isr_tmr_switch_task       #
    push %ax      # save ax
    mov $0x0c,%al # read register C in ISR
    out %al,$0x70 #  to keep getting
    in $0x71,%al  #  irq 8
    mov $0x20,%al # acknowledge interrupt (EOI) to
    out %al,$0xa0 # second controller PIC1
    out %al,$0x20 # main controller PIC0
    pop %ax       # restore ax
    sti           # enable interrupts
    iret

isr_tmr_switch_task:
  # start task switching
  mov %eax,isr_tmr_eax  # save eax,ebx
  mov %ebx,isr_tmr_ebx  # eax,ebx will be used as scratch
  mov osca_tsk_a,%ebx   # point ebx to active task
  cmpb $1,isr_tmr_yield # check if request is from osca_yield()
  jnz isr_tmr_switch_task_1
    # switch task requested from osca_yield()
    # stack is: [ rest of stack ...] IP, FLAGS
    mov 4(%esp),%eax # get eip before the call
    mov %eax,(%ebx)  # save to task.eip
    mov (%esp),%eax  # get eflags
    mov %eax,8(%ebx) # save to task.eflags
    mov %esp,%eax    # adjust esp to value before the call
    add $8,%eax      # skip FLAGS, IP
    mov %eax,4(%ebx) # save to task.esp
    jmp isr_tmr_switch_task_2 #  do the rest of task switch
isr_tmr_switch_task_1:
    # switch task from timer interrupt
    # stack is [ rest of stack ..] FLAGS, CS, IP
#    push %eax
#    mov $0x04040404,%eax
#    mov %eax,0xa0000+130
#    pop %eax

    mov (%esp),%eax  # get eip before irq from stack
    mov %eax,(%ebx)  # save to task.eip
    mov 8(%esp),%eax # get eflags before irq from stack
    mov %eax,8(%ebx) # save to task.eflags
    mov %esp,%eax    # adjust esp to value before irq
    add $12,%eax     # skip eip,cs,eflags
    mov %eax,4(%ebx) # save to task.esp
isr_tmr_switch_task_2:
  # continue the task switching
  mov %ebx,%esp # save gprs by preparing esp and then pusha
  add $48,%esp # move to end of task record
  pusha # pushes eax,ecx,edx,ebx,esp0,ebp,esi,edi to task record
  mov isr_tmr_eax,%eax # save proper eax,ebx
  mov %eax,44(%ebx) # to task.eax
  mov isr_tmr_ebx,%eax # save proper ebx
  mov %eax,32(%ebx) # to task.ebx
  add $48,%ebx # next task
  cmp $tsk_eot,%ebx # if last
  jl lbl4
    mov $tsk,%ebx # roll
  lbl4:
  mov %ebx,osca_tsk_a # save pointer to task record
  mov 4(%ebx),%esp # restore esp
  mov %esp,isr_tmr_esp # save esp, will be used as scratch
  mov (%ebx),%esp # restore eip
  mov %esp,isr_tmr_eip # save for jump
  mov 8(%ebx),%esp # get eflags
  mov %esp,isr_tmr_eflags # save to restore later
  mov %ebx,%esp # restore gprs
  add $16,%esp # position stack pointer for popa by skipping eip,esp,eflags,bits
  popa # write edi,esi,ebp,esp0,ebx,edx,ecx,eax

  cmpb $1,isr_tmr_yield # check if request is from osca_yield()
  jz isr_tmr_switch_task_3 # if from osca_yield() skip acknowledge interrupt
    # task switch from interrupt
    # acknowledge interrupt

#    push %eax
#    mov $0x04040404,%eax
#    mov %eax,0xa0000+140
#    pop %eax
#    incl 0xa0000+140

    push %ax # save to be clobbered %ax

    mov $0x0c,%al # read register C in ISR
    out %al,$0x70 #  to keep getting
    in $0x71,%al  #  irq 8

    mov $0x20,%al # acknowledge interrupt (EOI) to
    out %al,$0xa0 #  second controller PIC1
    out %al,$0x20 #  main controller PIC0

    pop %ax # restore %ax

isr_tmr_switch_task_3:
  movb $0,isr_tmr_yield # clear the flag that indicates call from osca_yield()
  mov isr_tmr_esp,%esp # restore task esp
  push isr_tmr_eflags # restore eflags by push
  popf # and pop
  sti  # enable interrupts
  jmp *isr_tmr_eip
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - ierr
.align 16,0x90
isr_err:
  cli
  pop %eax # pop error
  mov %eax,0xa0000 # to screen (top-left)
  lbl3:
    incl 0xa0004
  jmp lbl3
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - ikbd
.align 16,0x90
isr_kbd:
  cli # disable interrupts
  push %ax # save to be clobbered %ax
  in $0x60,%al # read keyboard port
  mov %al,osca_key # store
  mov %al,0xa0000+320-8 # on screen
  pusha # save registers
  call osca_keyb_ev # call keyb handler function
  popa # restore register
  mov $0x20,%al # ack interrupt
  out %al,$0x20 # ...
  pop %ax # restore %ax
  sti # enable interrupts
  iret
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - itck
.align 16,0x90
isr_tck:
  cli # disable interrupts
  incl 0xa0000+320-4 # on screen, top right corner
  push %ax # ack irq
  mov $0x20,%al
  out %al,$0x20
  pop %ax
  sti # enable interrupts
  iret
.space sector2+512-.,0X90
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - tasks
# sector3: #0x8200 tasks state table
.align 16,0x90
# default eflags disable interrupts
tsk: # eip,  esp,       eflags,     bits,       edi        esi        ebp        esp0       ebx        edx        ecx        eax
#  .long tsk4 ,0x000afa00,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk0 ,0x000afa00,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
  .long tsk1 ,0x000af780,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
  .long tsk2 ,0x000af500,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk3 ,0x000af280,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk4 ,0x000af000,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
tsk_eot:
#tsk_eot:
#  .long tsk5 ,0x000aed80,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk6 ,0x000aeb00,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk7 ,0x000ae880,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000

#  .long tsk8 ,0x000ae600,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk9 ,0x000ae380,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk10,0x000ae100,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk11,0x000ade80,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk12,0x000adc00,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk13,0x000ad980,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk14,0x000ad700,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk15,0x000ad480,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk16,0x000ad200,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk17,0x000acf80,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk18,0x000acd00,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#  .long tsk19,0x000aca80,0x00000000,0x00000000, 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000
#tsk_eot:
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - shutdown
#.align 16,0x90
#mode16: # protected mode to 16b mode
#.code16
#mov $0x20,%ax
#mov %ax,%ds
#mov %ax,%ss
#mov $0x7c00,%sp
#lidt ivtr
#mov %cr0,%eax
#and $0xfe,%al
#mov %eax,%cr0
#jmp $0x0,$rm
#.align 16,0x90
#rm:
#xor %ax,%ax
#mov %ax,%ds
#mov %ax,%ss
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - save
## save 2nd sector
#mov $0x0301,%ax # command 3, 1 sector
#mov $0x0002,%cx # track 0, sector 2
#xor %dh,%dh # head 0
#mov osca_drv_b,%dl # saved boot drive
#xor %bx,%bx # from es:bx (0:0x7e00)
#mov %bx,%es
#mov $0x7e00,%bx
#int $0x13
#jc 8f # if error
## display save ack?
##-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - done
#8:
#cli
#hlt
.space sector2+1024-.,0X90
